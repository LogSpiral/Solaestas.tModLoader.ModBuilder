using System.Text;
using Microsoft.CodeAnalysis;

namespace Solaestas.tModLoader.ModBuilder.Generators;

[Generator]
public class PathGenerator : ISourceGenerator
{
	public void Execute(GeneratorExecutionContext context)
	{
		var enabled = context.GetProperty("EnablePathGenerator", "true");
		if (enabled != "true")
		{
			return;
		}

		var modName = context.GetProperty("ModName", context.Compilation.Assembly.Name);
		var typename = context.GetProperty("PathTypeName", "ModAsset");
		var rootNamespace = context.GetProperty("PathNamespace", modName);
		var prefix = context.GetProperty("PathPrefix", string.Empty);
		if (prefix.Length > 0 && prefix[^1] != '/')
		{
			prefix += '/';
		}

		var source = new StringBuilder();
		var builder = new PathBuilder(source, modName, prefix);
		source.AppendLine($$"""
			// <auto-generated/>
			using Microsoft.Xna.Framework.Graphics;
			using Microsoft.Xna.Framework.Audio;
			using ReLogic.Content;
			using Terraria.ModLoader;
			namespace {{rootNamespace}};

			public static class {{typename}}
			{
				private static AssetRepository _repo;
				static {{typename}}()
				{
					_repo = ModLoader.GetMod("{{modName}}").Assets;
				}
			""");

		var paths = ScanResource(context, out var conflicts);
		TryFullName(paths, conflicts);
		TryAddDepth(paths, conflicts);
		foreach (var con in conflicts.Values)
		{
			context.ReportDiagnostic(Diagnostic.Create(Descriptors.MB0001, Location.None, string.Join(
				", ",
				con.Select(s => s.Value.ToString()))));
		}

		foreach (var member in paths)
		{
			if (!CheckValid(member.Name))
			{
				context.ReportDiagnostic(Diagnostic.Create(Descriptors.MB0002, Location.None, member.Path));
				continue;
			}
			builder.Append(member);
		}

		source.AppendLine("}");
		context.AddSource($"{typename}.g.cs", source.ToString());
	}

	private List<PathMember> ScanResource(in GeneratorExecutionContext context, out Dictionary<string, List<PathMember>> conflicts)
	{
		Dictionary<string, PathMember> paths = [];
		conflicts = [];
		foreach (var file in context.AdditionalFiles)
		{
			string pack = context.GetMetadata(file, "Pack", "false");
			if (!bool.TryParse(pack, out var shouldPack) || !shouldPack)
			{
				continue;
			}

			if (!context.TryGetMetadata(file, "ModPath", out var modPath))
			{
				continue;
			}

			var defaultName = Path.GetFileNameWithoutExtension(modPath);
			var member = new PathMember(modPath);
			if (char.IsDigit(defaultName[0]))
			{
				var dirname = Path.GetFileName(Path.GetDirectoryName(modPath));
				defaultName = $"{dirname}_{defaultName}";
				member = PathMember.Increase(member);
			}

			if (paths.TryGetValue(defaultName, out var exist))
			{
				if (!conflicts.TryGetValue(defaultName, out var list))
				{
					conflicts[defaultName] = list = [exist];
				}
				list.Add(modPath);
				continue;
			}
			paths.Add(defaultName, member);
		}

		foreach (var key in conflicts.Keys)
		{
			paths.Remove(key);
		}

		return [.. paths.Values];
	}

	/// <summary>
	/// 使用全名来避免部分重名
	/// </summary>
	/// <param name="context"></param>
	/// <param name="paths"></param>
	/// <param name="conflicts"></param>
	public static void TryFullName(List<PathMember> paths, Dictionary<string, List<PathMember>> conflicts)
	{
		foreach (var pair in conflicts.ToArray())
		{
			var list = pair.Value;
			int cannot = 0;

			for (int i = 0; i < list.Count - 1; i++)
			{
				// n位set表示第n个能不用全名解决重名问题
				for (int j = i + 1; j < list.Count; j++)
				{
					if (list[i].FullName.SequenceEqual(list[j].FullName))
					{
						cannot |= 1 << i;
						cannot |= 1 << j;
						break;
					}
				}
			}

			// 翻转cannot，得到能使用全名解决重名的位
			int can = cannot ^ ~(-1 << list.Count);

			// 全名无法解决重名
			if (can == 0)
			{
				continue;
			}

			// 全部能通过使用全名解决重名
			if (cannot == 0)
			{
				paths.AddRange(list.Select(s => s with
				{
					Style = PathStyle.FullName,
				}));
				conflicts.Remove(pair.Key);
				continue;
			}

			// 只有一个全名与其他不同
			if ((can & (can - 1)) == 0)
			{
				continue;
			}

			// 部分全名能解决的
			for (int i = list.Count - 1; i >= 0; i--)
			{
				if ((can & (1 << i)) != 0)
				{
					paths.Add(list[i] with { Style = PathStyle.FullName });
					list.RemoveAt(i);
				}
			}
		}
	}

	/// <summary>
	/// 添加前缀来避免重名
	/// </summary>
	/// <param name="context"></param>
	/// <param name="paths"></param>
	/// <param name="conflicts"></param>
	public static void TryAddDepth(List<PathMember> paths, Dictionary<string, List<PathMember>> conflicts)
	{
		foreach (var pair in conflicts.ToArray())
		{
			var list = pair.Value;
			for (int i = 0; i < list.Count; i++)
			{
				list[i] = PathMember.Increase(list[i]);
			}
			if (Recurse(list))
			{
				bool overlap = PathMember.HasOverlap(list);
				foreach (var member in list)
				{
					paths.Add(overlap ? member with { Style = PathStyle.Reduce } : member);
				}
				conflicts.Remove(pair.Key);
			}
		}

		static bool Recurse(List<PathMember> list, int depth = 0)
		{
			if (depth > 16)
			{
				return false;
			}
			for (int i = 0; i < list.Count - 1; i++)
			{
				bool conflict = false;
				PathMember baseMember = list[i];
				ReadOnlySpan<char> baseName = baseMember.Name;
				for (int j = i + 1; j < list.Count; j++)
				{
					PathMember other = list[j];
					if (baseName.SequenceEqual(other.Name))
					{
						list[j] = PathMember.Increase(other);
						conflict = true;
					}
				}
				if (conflict)
				{
					list[i] = PathMember.Increase(baseMember);
					Recurse(list, depth + 1);
					break;
				}
			}
			return true;
		}
	}

	public static bool CheckValid(ReadOnlySpan<char> name)
	{
		for (int i = 0; i < name.Length; i++)
		{
			var ch = name[i];
			if (ch is (>= 'a' and <= 'z')
				or (>= 'A' and <= 'Z')
				or (>= '0' and <= '9')
				or '_' or '\\' or '/' or '.' or ' ')
			{
				continue;
			}
			return false;
		}
		return true;
	}

	public void Initialize(GeneratorInitializationContext context)
	{
	}
}